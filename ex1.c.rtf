{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue255;\red255\green255\blue254;\red0\green0\blue0;
\red144\green1\blue18;\red154\green154\blue154;\red19\green120\blue72;\red252\green76\blue165;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c100000;\cssrgb\c100000\c100000\c99608;\cssrgb\c0\c0\c0;
\cssrgb\c63922\c8235\c8235;\cssrgb\c66667\c66667\c66667;\cssrgb\c3529\c53333\c35294;\cssrgb\c100000\c41176\c70588;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl420\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 #include\cf4 \strokec4  \cf2 \strokec2 <\cf5 \strokec5 stdio.h\cf2 \strokec2 >\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 int\cf4 \strokec4  main(\cf2 \strokec2 void\cf4 \strokec4 ) \{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3   \cf6 \strokec6 //initialize and open files\cf4 \cb1 \strokec4 \
\cb3   FILE *input;\cb1 \
\cb3   input = fopen(\cf5 \strokec5 "input.txt"\cf4 \strokec4 , \cf5 \strokec5 "r"\cf4 \strokec4 );\cb1 \
\cb3   FILE *output;\cb1 \
\cb3   output = fopen(\cf5 \strokec5 "output.txt"\cf4 \strokec4 , \cf5 \strokec5 "w"\cf4 \strokec4 );\cb1 \
\cb3   \cf2 \strokec2 int\cf4 \strokec4  m=\cf7 \strokec7 0\cf4 \strokec4 ;\cb1 \
\cb3   \cf6 \strokec6 //ask user for number of recourses \cf4 \cb1 \strokec4 \
\cb3   printf(\cf5 \strokec5 "Enter number of resouces:"\cf4 \strokec4 );\cb1 \
\cb3   scanf(\cf5 \strokec5 "%d"\cf4 \strokec4 , &m);\cb1 \
\cb3   \cf6 \strokec6 //acreate vectors for availible and total recourses\cf4 \cb1 \strokec4 \
\cb3   \cf2 \strokec2 int\cf4 \strokec4  E[m];\cb1 \
\cb3   \cf2 \strokec2 int\cf4 \strokec4  A[m];\cb1 \
\cb3   \cf2 \strokec2 for\cf4 \strokec4  (\cf2 \strokec2 int\cf4 \strokec4  i=\cf7 \strokec7 0\cf4 \strokec4 ; i<m; i++)\{\cb1 \
\cb3    fscanf(input,\cf5 \strokec5 "%d"\cf4 \strokec4 , &E[i]);\cb1 \
\cb3   \}\cb1 \
\cb3   \cf2 \strokec2 for\cf4 \strokec4  (\cf2 \strokec2 int\cf4 \strokec4  i=\cf7 \strokec7 0\cf4 \strokec4 ; i<m; i++)\{\cb1 \
\cb3     fscanf(input,\cf5 \strokec5 "%d"\cf4 \strokec4 , &A[i]);\cb1 \
\cb3   \}\cb1 \
\cb3   \cf2 \strokec2 int\cf4 \strokec4  n=\cf7 \strokec7 0\cf4 \strokec4 ;\cb1 \
\cb3   printf(\cf5 \strokec5 "Enter number of processes:"\cf4 \strokec4 );\cb1 \
\cb3   scanf(\cf5 \strokec5 "%d"\cf4 \strokec4 , &n);\cb1 \
\cb3   \cf2 \strokec2 int\cf4 \strokec4  C[n][m];\cb1 \
\cb3   \cf6 \strokec6 //scan Current allocation matrix\cf4 \cb1 \strokec4 \
\cb3   \cf2 \strokec2 for\cf4 \strokec4  (\cf2 \strokec2 int\cf4 \strokec4  i=\cf7 \strokec7 0\cf4 \strokec4 ; i<n; i++)\{\cb1 \
\cb3     \cf2 \strokec2 for\cf4 \strokec4  (\cf2 \strokec2 int\cf4 \strokec4  j=\cf7 \strokec7 0\cf4 \strokec4 ; j<m; j++)\{\cb1 \
\cb3       fscanf(input,\cf5 \strokec5 "%d"\cf4 \strokec4 , &C[i][j]);\cb1 \
\cb3     \}\cb1 \
\cb3   \}\cb1 \
\cb3   \cf6 \strokec6 //scan Request matrix\cf4 \cb1 \strokec4 \
\cb3   \cf2 \strokec2 int\cf4 \strokec4  R[n][m];\cb1 \
\cb3   \cf2 \strokec2 for\cf4 \strokec4  (\cf2 \strokec2 int\cf4 \strokec4  i=\cf7 \strokec7 0\cf4 \strokec4 ; i<n; i++)\{\cb1 \
\cb3     \cf2 \strokec2 for\cf4 \strokec4  (\cf2 \strokec2 int\cf4 \strokec4  j=\cf7 \strokec7 0\cf4 \strokec4 ; j<m; j++)\{\cb1 \
\cb3       fscanf(input,\cf5 \strokec5 "%d"\cf4 \strokec4 , &R[i][j]);\cb1 \
\cb3     \}\cb1 \
\cb3   \}\cb1 \
\cb3   \cf6 \strokec6 //keep this list to track whether recourse has finished\cf4 \cb1 \strokec4 \
\cb3   \cf2 \strokec2 int\cf4 \strokec4  process[n];\cb1 \
\cb3   \cf2 \strokec2 for\cf4 \strokec4  (\cf2 \strokec2 int\cf4 \strokec4  i=\cf7 \strokec7 0\cf4 \strokec4 ; i<n; i++)\{\cb1 \
\cb3     process[i]=\cf7 \strokec7 1\cf4 \strokec4 ;\cb1 \
\cb3   \}\cb1 \
\cb3   \cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf2 \cb3 \strokec2 for\cf4 \strokec4  (\cf2 \strokec2 int\cf4 \strokec4  i=\cf7 \strokec7 0\cf4 \strokec4 ; i<n; i++)\{\cb1 \
\pard\pardeftab720\sl420\partightenfactor0
\cf4 \cb3     \cf2 \strokec2 for\cf4 \strokec4  (\cf2 \strokec2 int\cf4 \strokec4  k=\cf7 \strokec7 0\cf4 \strokec4 ; k<n; k++)\{\cb1 \
\cb3       \cf6 \strokec6 //if process is still not processes\cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf4 \strokec4  (process[k]==\cf7 \strokec7 1\cf4 \strokec4 )\{\cb1 \
\cb3     \cf2 \strokec2 int\cf4 \strokec4  ok=\cf7 \strokec7 0\cf4 \strokec4 ;\cb1 \
\cb3     \cf6 \strokec6 //calculate if all requested resources can be given \cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 for\cf4 \strokec4  (\cf2 \strokec2 int\cf4 \strokec4  j=\cf7 \strokec7 0\cf4 \strokec4 ; j<m;j++)\{\cb1 \
\cb3       \cf2 \strokec2 if\cf4 \strokec4  (R[k][j]<=A[j] )\{\cb1 \
\cb3         ok++;\cb1 \
\cb3       \}\cb1 \
\cb3     \}\cb1 \
\cb3     \cf6 \strokec6 //if yes then execute process, release the recourses \cf4 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf4 \strokec4  (ok==m)\{\cb1 \
\cb3       \cf2 \strokec2 for\cf4 \strokec4  (\cf2 \strokec2 int\cf4 \strokec4  j=\cf7 \strokec7 0\cf4 \strokec4 ; j<m;j++)\{\cb1 \
\cb3         A[j]+=C[k][j];\cb1 \
\cb3         \cb1 \
\cb3       \}\cb1 \
\cb3       \cf6 \strokec6 //set process as terminated\cf4 \cb1 \strokec4 \
\cb3       process[k]=\cf7 \strokec7 0\cf4 \strokec4 ;\cb1 \
\cb3     \}\cb1 \
\cb3     \}\cb1 \
\cb3     \}\cb1 \
\cb3   \}\cb1 \
\cb3   \cf6 \strokec6 // after terminating all possible processes\cf4 \cb1 \strokec4 \
\cb3   \cf2 \strokec2 int\cf4 \strokec4  deadlock=\cf7 \strokec7 0\cf4 \strokec4 ;\cb1 \
\cb3   \cf2 \strokec2 for\cf4 \strokec4  (\cf2 \strokec2 int\cf4 \strokec4  i=\cf7 \strokec7 0\cf4 \strokec4 ; i<n; i++)\{\cb1 \
\cb3     \cf6 \strokec6 //if process is still not process it is in a deadlock\cf4 \cb1 \strokec4 \
\cb3       \cf2 \strokec2 if\cf4 \strokec4 (process[i]==\cf7 \strokec7 1\cf4 \strokec4 )\{\cb1 \
\cb3       deadlock=\cf7 \strokec7 1\cf4 \strokec4 ;\cb1 \
\cb3       fprintf(output,\cf5 \strokec5 "Process %d is in a deadlock\cf8 \strokec8 \\n\cf5 \strokec5 "\cf4 \strokec4 ,i+\cf7 \strokec7 1\cf4 \strokec4 );\cb1 \
\cb3       \}\cb1 \
\cb3   \}\cb1 \
\cb3  \cf6 \strokec6 // else there is no deadlock\cf4 \cb1 \strokec4 \
\cb3  \cf2 \strokec2 if\cf4 \strokec4 (deadlock==\cf7 \strokec7 0\cf4 \strokec4 )\{\cb1 \
\cb3    fprintf(output,\cf5 \strokec5 "No deadlock is detected"\cf4 \strokec4 );\cb1 \
\cb3  \}\cb1 \
\cb3  \cf6 \strokec6 //close files\cf4 \cb1 \strokec4 \
\cb3  fclose(input);\cb1 \
\cb3  fclose(output);\cb1 \
\
\cb3   \cf2 \strokec2 return\cf4 \strokec4  \cf7 \strokec7 0\cf4 \strokec4 ;\cb1 \
\cb3 \}\cb1 \
}